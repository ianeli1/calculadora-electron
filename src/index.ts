import { app, BrowserWindow, ipcMain } from "electron";
import type {
  SerialSendArgs,
  SerialPortSelectArgs,
  SerialReceiveArgs,
} from "./utils/types";
import { operationToNumber } from "./utils/utils";
import { SerialPort } from "serialport";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let win: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
    },
    autoHideMenuBar: true,
    frame: false,
    transparent: true,
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools({
    mode: "detach",
  });
  win = mainWindow;
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

let port: SerialPort | null = null;
let chosenPort: string | null = null;

const BAUD_RATE = 9600;

function openPort() {
  if (!chosenPort) {
    throw new Error("no port selected");
  }
  port = new SerialPort(
    {
      path: chosenPort,
      baudRate: BAUD_RATE,
      dataBits: 8,
      parity: "none",
      stopBits: 1,
    },
    (error) => {
      if (error) {
        console.log(error);
        throw new Error(
          `An error ocurred while opening port ${chosenPort}: ${error}`
        );
      }
    }
  );

  port.on("open", () => {
    console.log(`Port ${chosenPort} is open`);
  });

  port.on("error", (err) => {
    console.log(`An error ocurred in port ${chosenPort}`, err);
  });

  port.on("close", () => {
    console.log("Port is closed");
  });

  port.on("data", (chunk) => {
    try {
      const buffer = Buffer.from(chunk, "binary");
      const byte0 = buffer.readUint8(0);
      const byte1 = buffer.readUint8(1);

      const obj: SerialReceiveArgs = {
        result: byte1,
        error: (byte0 & 0b00000001) === 1,
      };

      console.log(
        `Received ${buffer}, byteLength: ${buffer.byteLength} from port ${chosenPort}`
      );

      console.log(
        `Result => ${obj.result}, is error: ${obj.error ? "yes" : "no"}`
      );

      win?.webContents.send("serial_receive", obj);
    } catch (e) {
      console.log(`Error receiving data:`, e);
      const obj: SerialReceiveArgs = {
        result: 999,
        error: true,
      };
      win?.webContents.send("serial_receive", obj);
    }
    // ipcMain.emit("serial_receive", obj);
  });
}

ipcMain.on("serial_send", (_, obj: SerialSendArgs) => {
  if (!port || port.closed) {
    openPort();
  }

  const data = [operationToNumber(obj.operation), obj.op1, obj.op2];

  const buffer = Buffer.from(data);

  console.log(
    `Sending ${data}, byteLength: ${buffer.byteLength} to port ${chosenPort}`
  );

  port.write(buffer);
});

ipcMain.on("serial_port_select", (_, obj: SerialPortSelectArgs) => {
  chosenPort = obj.port;
  console.log(`Updated chosen port to ${chosenPort}`);
  if (!port || port.closed) {
    openPort();
  }
});

ipcMain.handle("serial_port_list", async () => {
  const ports = await SerialPort.list();
  console.log(`Fetching serial port list: ${JSON.stringify(ports)}`);
  return ports.map((port) => port.path);
});
